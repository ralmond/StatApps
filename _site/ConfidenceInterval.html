<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.555">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Russell Almond">
<meta name="dcterms.date" content="2019-03-05">

<title>Introductory Statistics Apps - Confidence Intervals</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<meta name="shinylive:serviceworker_dir" content=".">
<script src="site_libs/quarto-contrib/shinylive-0.5.0/shinylive/load-shinylive-sw.js" type="module"></script>
<script src="site_libs/quarto-contrib/shinylive-0.5.0/shinylive/run-python-blocks.js" type="module"></script>
<link href="site_libs/quarto-contrib/shinylive-0.5.0/shinylive/shinylive.css" rel="stylesheet">
<link href="site_libs/quarto-contrib/shinylive-quarto-css/shinylive-quarto.css" rel="stylesheet">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">Introductory Statistics Apps</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./about.html"> 
<span class="menu-text">About</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#confidence-intervals" id="toc-confidence-intervals" class="nav-link active" data-scroll-target="#confidence-intervals">Confidence Intervals</a></li>
  <li><a href="#catching-fish-in-our-net" id="toc-catching-fish-in-our-net" class="nav-link" data-scroll-target="#catching-fish-in-our-net">Catching Fish in Our Net</a></li>
  <li><a href="#random-points" id="toc-random-points" class="nav-link" data-scroll-target="#random-points">Random Points</a></li>
  <li><a href="#interpreting-confidence-intervals" id="toc-interpreting-confidence-intervals" class="nav-link" data-scroll-target="#interpreting-confidence-intervals">Interpreting Confidence Intervals</a>
  <ul class="collapse">
  <li><a href="#classical-approach" id="toc-classical-approach" class="nav-link" data-scroll-target="#classical-approach">Classical Approach</a></li>
  <li><a href="#bayesian-approach" id="toc-bayesian-approach" class="nav-link" data-scroll-target="#bayesian-approach">Bayesian Approach</a></li>
  <li><a href="#which-approach-is-better" id="toc-which-approach-is-better" class="nav-link" data-scroll-target="#which-approach-is-better">Which approach is better</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Confidence Intervals</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Russell Almond </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">March 5, 2019</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<section id="confidence-intervals" class="level2">
<h2 class="anchored" data-anchor-id="confidence-intervals">Confidence Intervals</h2>
<p>The simple heuristic for the confidence interval is that if we take a sample and calculate an estimator and a standard error for that estimator; 95% of the time the estimand will be within 2 standard errors of the estimate. This heuristic works best for sample means, because by the central limit theorem the distribution of the sample mean will be approximately normal. It also works fairly well for other statistics, like regression slopes.</p>
<p>Let the goal be to produce an interval which <span class="math inline">\((1-\alpha)\)</span>% of the time captures the estimand. If we assume that the estimate, <span class="math inline">\(\widetilde{f(Y)}\)</span>, is approximately normally distributed with a mean of the estimand, <span class="math inline">\(f(Y)\)</span> and a standard deviation of the standard error of the estimate, <span class="math inline">\(\sigma_{\widetilde{f(Y)}}\)</span>, (i.e., we are assuming that central limit theorem holds at least approximately for <span class="math inline">\(\widetilde{f(Y)}\)</span>), then we can produce a confidence interval using the following expression: <span class="math display">\[ \widetilde{f(Y)} \pm z_{1-\alpha/2}\ \sigma_{\widetilde{f(Y)}}\; .\]</span></p>
<p>Ugh. Lets break this apart using an example. Letâ€™s say what we are interested in is the sample mean. Then <span class="math inline">\(\widetilde{f(Y)} = \bar Y\)</span> is just the sample mean. The quantile <span class="math inline">\(z_{1-\alpha/2}\)</span> depends on the desired accuracy. The default choice is <span class="math inline">\(1-\alpha=.95\)</span>, so <span class="math inline">\(1-\alpha/2 = .975\)</span>, and looking this up on the normal table <span class="math inline">\(z_{.975}\approx 1.96 \approx 2\)</span>. Finally, <span class="math inline">\(\sigma_{\widetilde{f(Y)}}\)</span> is the standard error of the mean, so if the population standard deviation of <span class="math inline">\(Y\)</span> is <span class="math inline">\(\sigma_Y\)</span> and the sample size is <span class="math inline">\(N\)</span>, then <span class="math inline">\(\sigma_{\widetilde{f(Y)}} = \sigma_Y/\sqrt{N}\)</span>. This gives us the slightly easier to look at: <span class="math display">\[\bar Y \pm 1.96 \sigma_Y/\sqrt{N} \approx \bar Y \pm 2 \sigma_Y/\sqrt{N}\ ;\]</span> Note that we are assuming that <span class="math inline">\(\sigma_Y\)</span> is known here. If we need to estimate it from the data, we need a slightly different formula given later.</p>
</section>
<section id="catching-fish-in-our-net" class="level2">
<h2 class="anchored" data-anchor-id="catching-fish-in-our-net">Catching Fish in Our Net</h2>
<p>There are two interpretations of confidence intervals (c.i.s): classical and Bayesian (although the latter are often called <em>credibility intervals</em> to distinguish them). As the Bayesian interpretation requires fewer assumptions, we will explore it first.</p>
<p>In the classical interpretation the c.i., the c.i. is like a net that is cast into the sea. It either will or will not catch the fish (the estimand). On average, the c.i. will catch the fish <span class="math inline">\((1-\alpha)\)</span>% of the time; this probability comes from the sampling. On a given time, we either will or will not have the fish in the net, but if we through it out many times, we will catch the fish <span class="math inline">\((1-\alpha)\)</span>% of the time.</p>
</section>
<section id="random-points" class="level2">
<h2 class="anchored" data-anchor-id="random-points">Random Points</h2>
<p>Select the number of repetitions (how many times we through the net), the sample size (the size of the net) as well as the parameters of the population.</p>
<p>You may need to press the regenerate button to get the graph to have the right symbols.</p>
<pre class="shinylive-r" data-engine="r"><code>#| standalone: true
#| viewerHeight: 1500
library(shiny)

rpointnotes &lt;- ""
rintnotes &lt;-""


Z &lt;- rnorm(100)
p1 &lt;- floor(abs(Z)) +1
ui &lt;- fluidPage(
inputPanel(
    selectInput("M", label = "Number of Repetitions:",
                choices = c(50, 100, 200), selected = 100),
    selectInput("N", label = "Sample Size:",
                choices = c(1,5,10,25,50,100), selected = 1),
    sliderInput("my", label = "Mean of Y:",
              min=0, max=100, value=50, step=1),
    sliderInput("sy", label = "Standard Deviation of Y:",
              min = 0.2, max = 25, value = 10, step = 0.1),
    actionButton("go",label="(Re)Generate")),
mainPanel(
  plotOutput("plot"),
  fluidRow(textOutput("sem")),
  fluidRow(textOutput("text1")),
  fluidRow(textOutput("text2")),
  fluidRow(textOutput("text3")),
  tags$ul(
    tags$li("Approximaly 2/3 of the data points should be within 1 SE of the mean (plotted as circles)"),
    tags$li("* Approximately 95 percent of the data points should be within 1 SE of the mean (circles and triangles)."),
    tags$li("Approximately 5 percent of the data points should be 2 SEs or more away from the mean (plotted at diamonds).")),
  p("Note that changing the mean and sd of the population only changes the scales on the graph, not the structure of the problem."),
  h2("Random Intervals"),
  p("Taking the sample mean and going plus or minus two standard errors produces a confidence interval."),
  markdown("Actually, the two standard error rule is based on looking up the .975 (1-.05/2) point on the [normal table](NormalCalculator.Rmd).  We could put other values in there as well (50%, 75%, 90% and 99% are common choices).  This will adjust the length of the slider."),
  sliderInput("alpha","Confidence",
                       min=0,max=1,value=.95,step=.01),
  plotOutput("plotI"))
               

server &lt;- function (input,output) {

  dataSet &lt;- reactiveValues(Z=Z,sem=10,
                             pch=ifelse(p1 &gt;2, 5, p1), 
                         M=100,
                 my=50,sy=10)
  
  observeEvent(input$go,{
      M &lt;- as.numeric(input$M)
      dataSet$Z &lt;- rnorm(M)
      sy &lt;- as.numeric(input$sy)
      dataSet$sem &lt;- sy / sqrt(as.numeric(input$N))
      p1 &lt;-floor(abs(dataSet$Z)) + 1
      dataSet$pch &lt;- ifelse(p1 &gt; 2, 5, p1)
      my &lt;- as.numeric(input$my)
  })

  output$plot &lt;- renderPlot({
      sem &lt;- dataSet$sem
      my &lt;- dataSet$my
      sy &lt;- dataSet$sy
      X &lt;- dataSet$Z * sem + my
      M &lt;- length(X)
      curve(
        dnorm(x, my, sem),
        xlim = c(my - 3.5 * sy, 
                 my + 3.5 * sy),
        ylab = "density",
        xlab = "Sample Mean"
      )
      abline(v = my)
      abline(h = 0)
      text(my + .25 * sem, .02, expression(mu[Y]))
      abline(v = my - 2 * sem)
      text(my - 2 * sem + .25 * sem, 0.0025, "-2SE")
      abline(v = my - sem)
      text(my - sem + .25 * sem, 0.005,"-1SE")
      abline(v = my + sem)
      text(my + sem + .25 * sem, 0.005, "+1SE")
      abline(v = my + 2 * sem)
      text(my + 2 * sem + .25 * sy, 0.0025, "2SE")
      points(X, rep(0, M), pch = dataSet$pch)
    })
   output$sem &lt;- renderText({
     sem &lt;- dataSet$sem
      paste(
        "Standard Error = ",
        round(sem, 3),".")})
   output$text1 &lt;- renderText({
     pch &lt;- dataSet$pch
     paste(sum(pch == 1),
        "Estimates less than 1 SE from mean;")
    })
   output$text2 &lt;- renderText({
     pch &lt;- dataSet$pch
     paste(sum(pch == 2),
        "Estimates between 1 and 2 SE from mean;")
    })
   output$text3 &lt;- renderText({
     pch &lt;- dataSet$pch
     paste(sum(pch == 5),
        "Estimates more than 2 SE from mean.")
   })
   output$plot1 &lt;- renderPlot({
      sem &lt;- dataSet$sem
      my &lt;- dataSet$my
      X &lt;- dataSet$Z * sem + my
      M &lt;- length(X)
      i &lt;- 1:M
      alpha &lt;- (1-as.numeric(input$alpha))/2
      X.low &lt;- X +qnorm(alpha)*sem
      X.high &lt;- X + qnorm(1-alpha)*sem
      pch1 &lt;- ifelse(X.low &lt;= my &amp; my &lt;= X.high,1,5)
      plot(c(my-3.5*sem,my+3.5*sem),c(0,M+1),
             ylab="Trial",xlab="Sample Mean",
           main=paste(100*(1-2*alpha),"% Confidence Intervals"), type="n")
      points(X,i,pch=pch1)
      segments(X.low,i,X.high,i,lty=pch1,
               col=ifelse(pch1==5,1,5))
      abline(v = my)
    })



}
shinyApp(ui=ui,server=server)</code></pre>
<p>The number of confidence intervals that donâ€™t overlap the target line should be around <span class="math inline">\(\alpha\)</span> (the number in the slider) of the total number of intervals.</p>
<ul>
<li>This graph and the random points above are based on the same data. For the 95% interval; the data points where the intervals donâ€™t cross correspond to the data points outside of the 95% region.</li>
</ul>
</section>
<section id="interpreting-confidence-intervals" class="level2">
<h2 class="anchored" data-anchor-id="interpreting-confidence-intervals">Interpreting Confidence Intervals</h2>
<p>The number <span class="math inline">\(\alpha\)</span>, most often 95%, is known as the <em>level</em> of the confidence interval. The level is interpreted as a probability, but there are two schools of thought for interpreting it.</p>
<section id="classical-approach" class="level3">
<h3 class="anchored" data-anchor-id="classical-approach">Classical Approach</h3>
<p>The classical statistical paradigm regards the population mean as a fixed but unknown quantity. The true value is either in or not in the interval, we donâ€™t know which.</p>
<p>Random variability comes from the sampling, therefore the 95% comes from imagining different worlds in which we repeated the same sampling and analysis over and over again. 95% of the time, our net (the interval) will catch the fish.</p>
<p>In the classical paradigm, we canâ€™t say that their is a 95% chance that the fish is in the net, as we canâ€™t express the position of the fish as a probability: only the position of the net.</p>
</section>
<section id="bayesian-approach" class="level3">
<h3 class="anchored" data-anchor-id="bayesian-approach">Bayesian Approach</h3>
<p>The Bayesian paradigm makes the position of the fish a random variable. To do that, however, it needs an additional assumption: a probability distribution for the initial position of the fish.</p>
<p>For simplicity, assume that all positions of the fish are [equally likely]<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>. Using that assumption and Bayesâ€™s Theorem, calculate the posterior probability of the fish (after observing the data). The interval that is constructed is called a <em>credibility interval.</em> There is a 95% chance that the fish is in the credibility interval (at least if the model, both the prior assumption and the normal distribution of the data is correct).</p>
</section>
<section id="which-approach-is-better" class="level3">
<h3 class="anchored" data-anchor-id="which-approach-is-better">Which approach is better</h3>
<p>Actually, most people want both interpretations to hold. They want a proceedure that catches the fish 95% of the time and they want the fish to be in the net 95% of the time.</p>
<p>Fortunately, when we use the approximation that all positions of the fish are equally likely, the two intervals are the same. The abbreviation <em>c.i.</em> could stand for either confidence or credibility interval.</p>
<p>The Bayesian interpretation relies on an additional assumption, but both intervals rely on assumptions about the distribution of the observed data. In particular, in this example, we are using the normal distribution to calculate the intervals. That means that the distribution must be close enough to normal that by the central limit theorem, it is reasonable to think that the mean is approximately normally distributed.</p>
<p>Both c.i.s break down if the there is a problem with the sample. If this was a convenience sample and not a random one, the normal distribution around the population mean might not be at all right. The c.i. only talks about random error and not bias.</p>


</section>
</section>


<div id="quarto-appendix" class="default"><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p>The equally likely assumption is actually a bit nonsensical as we probably expect the fish to in the middle of the pond and not out past the orbit of Pluto. However, if we have enough data, the assumption will not play a big role in our estimate.<a href="#fnref1" class="footnote-back" role="doc-backlink">â†©ï¸Ž</a></p></li>
</ol>
</section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "î§‹";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>